---
title: 红宝书重读笔记之第三章
date: 2022-04-22 15:08:44
tags: [JavaScript,前端,红宝书]
categories: [前端,JavaScript]
---
# 红宝书重读笔记之第三章
第三章主要是一些语言基础，包括基本变量，基本语句等。简单但是还是挺杂乱的的。

## 语法
一些基本的变量命名问题。  
例如，规避关键字，区分大小写，变量no数字开头，尽量使用单驼峰命名规则。
语句问题：
还是加上分号";"，多用代码块等等。

## 变量
第四版的红宝书最大的更新点就是主要是基于ES6的语法。
### var let const
三个其实是老生常谈的一些问题。  
1. var  
  var的作用域是函数作用域，定义在函数内部就是局部变量，虽然其实可以通过省略var，来使这个变量变成全局变量，但是不推荐这样做。  
  另外var还有变量提升，就是可以在定义前访问（虽然当然是undefined）  
  
    ```
    console.log(a);
    var a = 'a';  
    ```

    上述代码其实等价于:  
      ```
      var a;
      console.log(a);
      a = 'a';
      ```

    这就是变量提升。
    嗷，还有，var的变量是可以重复声明的
2. let  
   let，ES6新加的声明方式，和var的作用差不多，作用域不同，let的作用域是块级作用域，no函数作用域，一个if或者for代码块就可以把let限制死，其实这是个好事。  
   let声明的变量不能被重复声明。  
   let有暂时性死区，js引擎其实也会注意到声明在后面的let声明的变量，但是，不能在声明之前以任何形式去使用这个变量，在声明之前执行的任何瞬间都称之为暂时性死区。  
   ######   一些关于全局变量的事情：
   var声明的全局变量会放到window对象下面挂载。但是let不会，但是也是全局。  
   ######  一些条件声明：  
   正如上面所说，let具有暂时性死区，所以就不可能存在条件声明，因为如果要使用条件声明，就务必要去判断变量存不存在，这本身就是对变量的访问，在let中不可行。
3. const
   const和let其实差不多，就是只有一点，就是，const声明的值不可以被改变，当然，这样子就导致const必须在声明变量的同时赋值。  
   我们虽然说的const变量无法改变，但是如果const存储的是对象或者其他引用类型的值的话，其实是可以修改的，因为const存储的其是只是这个值得引用。
### 声明风格
<p style="color:#c73e3a;font-weight:bolder;font-size:4rem;">CONST>LET>VAR</p>

## 数据类型
##### 简单数据类型
六种简单数据类型，或者称之为原始类型，undefined,null,string,number,boolean,symbol(symbol是ES6新加的)
##### 引用数据类型
五种引用数据类型，Object,Array,Function,RegExp,Date
#### 对于typeof结果可能的值
* undefined
* boolean
* string
* number
* object
* function
* symbol
> 对于Array等类型，typeof得出来的结果是object

### Undefined类型
Undefined类型只有一个值，就是undefined。  
主要就是表示一个经过初始化但是没有经过赋值的变量的状态。  
但是其实不管是声明未赋值还是未声明的变量，经过typeof的结果都是‘undefined’，所以,在实际开发中,声明变量的同时给予一个初始值,哪怕是0或者是空字符串.这样在后续碰到undefined的变量时,就能很清晰的知道这个变量是没有定义而不是没有初始化.

### Null类型 
Null和Undefined太像了,也是只有一个特殊值,null,表示一个空对象,和undefined不同的是.在实际开发中,是推荐把声明但是为打算赋值的对象设置为null的(不然他就是undefined了😂),undefined和null主要是区分了原始值和空对象.

### Boolean类型
首先明确一点，在js里面，true，false不能和0，1相互等价。  
***Here is a table:***  
<table>
    <tr>
        <th>数据类型</th>
        <th>to true</th>
        <th>to false</th>
    </tr>
    <tr>
        <th>Boolean</th>
        <th>true</th>
        <th>false</th>
    </tr>
    <tr>
        <th>String</th>
        <th>非空字符串</th>
        <th>""(空字符串)</th>
    </tr>
    <tr>
        <th>Number</th>
        <th>非零数值</th>
        <th>0,NaN</th>
    </tr>
    <tr>
        <th>Object</th>
        <th>任意对象</th>
        <th>null</th>
    </tr>
    <tr>
        <th>Undefined</th>
        <th>N/A</th>
        <th>undefined</th>
    </tr>
</table>

### Number类型
经典的IEEE754标准(考研时候差点没把我折磨死跍😒)  
IEEE754精确度可以达到17位小数，但是他处理不了
``` 
0.1 + 0.2 === 0.3
```
这样的问题，我认为是二进制和754带来的问题.

##### 大小数
Infinity,js中的极限,不能用于计算.  
js甚至专门提供一个函数来判断这个数是不是极限.  
```
console.log(isFinite(num))
```

有两种方式去获取这个值
```
Number.MAX_VALUE,Number.MIN_VALUE;
Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY;
```

##### NaN
not a number.其如其名.

#### 数字转换
##### Number()
强调转型.  
true => 1 ,false => 0;  
null => 0; 
undefined => NaN;  
String =>{  
  &emsp;识别16进制,no8进制  
  &emsp;字符串开头数字(忽略0),识别  
  &emsp;空字符串 => 0  
  &emsp;其他情况 => NaN  
}

##### parseInt()
parseInt()更强调字符串转化为数字.  
另外空字符串在这里就是NaN,而不是像Number()那样识别为0;  
支持0或者0x开头字符串识别为8进制或者16进制;  
也支持携带第二个参数指定识别的进制.

##### parseFloat()
和parseInt()感觉没什么不同.

#### String类型
先来点无聊的东西;  
ES中的字符串其实是不可变的,字符串重新的赋值其实是一个销毁再重新赋值的一个过程.,当然这个其实也不重要.  

##### toString()转化字符串
JS提供toString()方法用来将其他类型的值转化为字符串,几乎所有值都有这个方法.包括字符串(字符串调用这个方法主要是用于简单返回自己的一个副本),但是null和undefined没有toString()方法.  
另外一个有意思的点就是:  
数字的toString()方法其实是可以接受参数的,用来指定转换成字符串后用那种进制去显示.  

##### String()
当不确定一个值是否为null或者是undefined的时候,可以使用String(arg)方法,如果arg有toString()方法就调用toString(),如果没有,就以字符串的形式返回字面量值.

##### 模板字面量
模板字面量是ES6新加内容,我认为还比较实用,或者成为有意思.
* 模板字面量用反引号
* 可以保留换行符,这是单引号或者双引号做不到的
* 用${}来插入变量